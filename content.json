{"meta":{"title":"Calvin的博客","subtitle":"博客","description":"Welcome to the darkside of me","author":"John Doe","url":"http://47.118.73.148","root":"/"},"pages":[{"title":"","date":"2022-04-05T10:48:02.700Z","updated":"2022-04-05T10:48:02.689Z","comments":false,"path":"about/index.html","permalink":"http://47.118.73.148/about/index.html","excerpt":"","text":"About Me Calvin 关于我 - CQU - Computer Science - Undergraduate Student CV-Learner 📷爱好者 会一点ArcGIS, QGIS 技术栈：Python, Java, C++, HTML, CSS, Javascript, Vue 关于博客 分享编程技术，分享生活，分享知识。 框架-hexo 主题-volantis 部署在阿里云 小站已经开通了评论 填写名称、邮箱即可评论 联系我 QQ：1969347522 邮箱：&#x72;&#x71;&#120;&#x31;&#x32;&#49;&#x33;&#x38;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#x6d; 开始于21-06-07对本站保留一切权利 =_=工作邮箱: &#x72;&#113;&#x78;&#49;&#x32;&#x31;&#x33;&#x38;&#x40;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#109;"},{"title":"所有分类","date":"2021-12-04T14:22:37.682Z","updated":"2021-06-07T16:44:36.693Z","comments":true,"path":"categories/index.html","permalink":"http://47.118.73.148/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-06-07T16:45:38.805Z","updated":"2021-06-07T16:45:38.796Z","comments":true,"path":"tags/index.html","permalink":"http://47.118.73.148/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MNIST数据集手写数字识别","slug":"mnist数据集手写数字识别","date":"2022-05-09T02:55:41.000Z","updated":"2022-05-09T03:40:12.192Z","comments":true,"path":"2022/05/09/mnist数据集手写数字识别/","link":"","permalink":"http://47.118.73.148/2022/05/09/mnist%E6%95%B0%E6%8D%AE%E9%9B%86%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/","excerpt":"","text":"MNIST数据集手写数字识别1. 神经网络架构​ 对于识别分类MNIST数据集中手写数字的问题，由于识别分类任务相对简单，我没有采用CNN网络，而是设计了由三层全连接层构成的神经网络。 ​ 此模型由三层全连接网络组成，输入层的大小为784，即输入图片大小（28 * 28），第一层隐藏层网络结点为100，第二层为100，第三层为输出层，由于有10个不同结果，采用Softmax，有10个节点，这些参数都可以在代码中基于训练结果进行调整。上图展示了大致的网络架构，但由于图片大小有限，具体节点数量与图片中的数量不同。 2. MNIST数据读取MNIST数据集可以在其官网下载，本文中采用Tensorflow中data_load()函数直接读取MNIST数据集 3. 代码部分部分注释由copilot辅助生成，可能存在问题 import randomimport numpy as npimport timeimport matplotlib.pyplot as pltimport h5py# 1. MNIST数据集读取及预处理（借助Tensorflow中的load_data））from tensorflow.keras.datasets.mnist import load_data(train_x, train_y), (test_x, test_y) = load_data() # 利用Tensorflow中的MNIST数据集读取函数读取数据集train_x, test_x = train_x / 255, test_x / 255 # 归一化# 2. 基础函数# 2.1 隐含层的激活函数def sigmoid(x): return 1 / (1 + np.exp(-x))# 2.2 输出层的激活函数def softmax(y): c = np.max(y) y = y - c sum = np.sum(np.exp(y)) return np.exp(y) / sum# 2.3 定义均方误差损失函数定义def loss(y_pre, y_grtru): return np.sum(np.square(y_pre - y_grtru))# 2.4 定义交叉熵损失函数def cross_entropy_loss(y_pre, y_grtru): return -np.sum(y_grtru * np.log(y_pre) + (1 - y_grtru) * np.log(1 - y_pre))# 2.5 数据集转置函数def data_transpose(x, y): y_t = np.zeros((y.size, 1, 10)) for i in range(0, y.size): y_t[i, 0, y[i]] = 1 return x.reshape(y.size, 1, x[0].size), y_t# 2.6 模型权重导入def get_model(weight_path): h5f = h5py.File(weight_path, &#x27;r&#x27;) w1 = h5f[&#x27;w1&#x27;][:] b1 = h5f[&#x27;b1&#x27;][:] w2 = h5f[&#x27;w2&#x27;][:] b2 = h5f[&#x27;b2&#x27;][:] w3 = h5f[&#x27;w3&#x27;][:] b3 = h5f[&#x27;b3&#x27;][:] return w1, w2, w3, b1, b2, b3# 3. 网络搭建# 3.1 初始化模型def genarate_model(): w1 = np.random.normal(0, 2 / width_input, (width_input, width_net1)) b1 = np.random.normal(0, 2 / width_net1, (width_net1,)) w2 = np.random.normal(0, 2 / width_net1, (width_net1, width_net2)) b2 = np.random.normal(0, 2 / width_net2, (width_net2,)) w3 = np.random.normal(0, 2 / width_net2, (width_net2, width_net3)) b3 = np.random.normal(0, 2 / width_net3, (width_net3,)) return w1, w2, w3, b1, b2, b3# 3.2 基本参数设置# 网络模型结构参数width_input = 784 # 输入层神经网络节点数=28*28width_net1 = 100 # 第一层神经网络节点数width_net2 = 100 # 第二层神经网络节点数width_net3 = 10 # 输出层神经网络节点数# 模型训练参数epoch = 15 # 训练轮数way_dec_lr = 1 # input:1 or 2&quot;&quot;&quot;学习率更新方式，选1，表示每lr_dec_epoch轮固定按lr_dec_rate比例减少学习率选择2，表示记录5次学习率大小，当当前轮次loss值大于前nub次（包括本次）loss平均值时，学习率自动降为当前学习率0.1倍，当学习率降为last_lr时，训练终止，保存模型&quot;&quot;&quot;nub = 3 # 设置记录nub次loss值last_lr = 0.0001 # 方式2时，最终截止学习率值learn_rate = 0.01 # 默认学习率init_learn_rate = 0.01 # 初始学习率lr_dec_epoch = 10 # 设置每10轮更新一次学习率lr_dec_rate = 0.5 # 跟新学习率倍数savepath = &#x27;weight4.h5&#x27; # 保存模型地址loadmodel = &#x27;weight3.h5&#x27; # 当为迁移学习时，载入模型地址（请确保本次训练模型结构与加载的模型一致）isretrain = False # 是否为迁移学习True or False# 定义网络输入层x = np.zeros((width_input,))# 定义网络第一层a1 = np.zeros((width_net1,))# 定义网络隐藏层a2 = np.zeros((width_net2,))# 定义网络输出层y = np.zeros((width_net3,))# 初始化nub个临时保存模型的参数,以便在早停前选取最优模型w11 = np.zeros((nub, width_input, width_net1))b11 = np.zeros((nub, width_net1))w21 = np.zeros((nub, width_net1, width_net2))b21 = np.zeros((nub, width_net2))w31 = np.zeros((nub, width_net2, width_net3))b31 = np.zeros((nub, width_net3))# 模型参数生成if isretrain: w1, w2, w3, b1, b2, b3 = get_model(loadmodel)else: w1, w2, w3, b1, b2, b3 = genarate_model()# 初始化参数z（其中a=sigmoid（z））z1 = np.dot(x, w1) + b1z2 = np.dot(a1, w2) + b2z3 = np.dot(a2, w3) + b3# 3.3 定义前向传播def feedforward(a, w, b): return sigmoid(np.dot(a, w) + b)# 3.4 保存模型def save_model(savepath, w_1, w_2, w_3, b_1, b_2, b_3): filename = savepath h5f = h5py.File(filename, &#x27;w&#x27;) h5f.create_dataset(&#x27;w1&#x27;, data=w_1) h5f.create_dataset(&#x27;w2&#x27;, data=w_2) h5f.create_dataset(&#x27;w3&#x27;, data=w_3) h5f.create_dataset(&#x27;b1&#x27;, data=b_1) h5f.create_dataset(&#x27;b2&#x27;, data=b_2) h5f.create_dataset(&#x27;b3&#x27;, data=b_3) h5f.close# 4. 模型训练start_time = time.perf_counter() # 计时# 初始化记录nub次loss值loss2loss2 = np.zeros((nub,))# 训练模型train_record = []for n in range(0, epoch + 1): print(&quot;==================================== Epoch %d ====================================&quot; % (n + 1)) # 方式1改变学习率 if way_dec_lr == 1: learn_rate = init_learn_rate * lr_dec_rate ** (int(n / lr_dec_epoch)) # 学习率随着学习轮数指数递减 # 打乱训练和测试样本 r = np.random.permutation(60000) train_x = train_x[r, :, :] train_y = train_y[r] start = time.perf_counter() # 计时 # 训练模型 for i in range(0, 60000): # 向前传播 x = np.array(train_x[i]) x = x.reshape(width_input, ) z1 = np.dot(x, w1) + b1 a1 = feedforward(x, w1, b1) z2 = np.dot(a1, w2) + b2 a2 = feedforward(a1, w2, b2) z3 = np.dot(a2, w3) + b3 y = feedforward(a2, w3, b3) y_t = np.zeros((width_net3,)) y_t[train_y[i]] = 1 # 反向传播 eta3 = (-y_t / y + (1 - y_t) / (1 - y)) * sigmoid(z3) * (1 - sigmoid(z3)) # 此为反向传播过程中中间参数，下同 eta2 = np.dot(eta3, np.transpose(w3)) * sigmoid(z2) * (1 - sigmoid(z2)) eta1 = np.dot(eta2, np.transpose(w2)) * sigmoid(z1) * (1 - sigmoid(z1)) b3 = b3 - learn_rate * eta3 b2 = b2 - learn_rate * eta2 b1 = b1 - learn_rate * eta1 w3 = w3 - learn_rate * np.dot(a2.reshape(width_net2, 1), eta3.reshape(1, width_net3)) # w2 = w2 - learn_rate * np.dot(a1.reshape(width_net1, 1), eta2.reshape(1, width_net2)) w1 = w1 - learn_rate * np.dot(x.reshape(width_input, 1), eta1.reshape(1, width_net1)) # 训练过程进度条加载 finish = &quot;▓&quot; * (i // 1000) need_do = &quot;-&quot; * (60 - (i // 1000)) progress = ((i // 1000) / 60) * 100 duration = dur = time.perf_counter() - start print(&quot;\\rTraining : &#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;.format(progress, finish, need_do, dur), end=&quot;&quot;) time.sleep(0.00005) print() loss1 = 0 True_num = 0 # 加载测试集，计算loss和precition start = time.perf_counter() # 计时 for i in range(0, 10000): # 向前传播，计算预测结果 x = np.array(test_x[i]) x = x.reshape(1, width_input) y_t = np.zeros((width_net3,)) y_t[test_y[i]] = 1 a1 = feedforward(x, w1, b1) a2 = feedforward(a1, w2, b2) y = feedforward(a2, w3, b3) if test_y[i] == np.argmax(y, axis=1): # 若预测正确，则正确数 +1，计算正确率 True_num = True_num + 1 loss1 = loss1 + cross_entropy_loss(y, y_t) # 测试过程进度条加载 finish = &quot;▓&quot; * ((i + 1) // 1000) need_do = &quot;-&quot; * (10 - ((i + 1) // 1000)) progress = (((i + 1) // 1000) / 10) * 100 duration = dur = time.perf_counter() - start print(&quot;\\rTesting : &#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;.format(progress, finish, need_do, dur), end=&quot;&quot;) time.sleep(0.00005) print() precision = True_num / 10000 * 100 # 方式2改变学习率，利用队列方式记录连续nub次loss值 if way_dec_lr == 2: # 临时存储模型 j = range(1, nub) k = range(0, nub - 1) w11[j] = w11[k] b11[j] = b11[k] w21[j] = w21[k] b21[j] = b21[k] w31[j] = w31[k] w11[0] = w1 b11[0] = b1 w21[0] = w2 b21[0] = b2 w31[0] = w3 b31[0] = b3 loss2[j] = loss2[k] loss2[0] = loss1 # 判断是否改变学习率 if loss2[0] &gt; np.mean(loss2) and loss2[nub - 1] &gt; 0: learn_rate = learn_rate * 0.1 if learn_rate &lt; last_lr: save_model(savepath, w11[np.argmin(loss2)], w21[np.argmin(loss2)], w31[np.argmin(loss2)], b11[np.argmin(loss2)], b21[np.argmin(loss2)], b31[np.argmin(loss2)]) print(&quot;Epoch:&quot;, n + 1, &quot;| Learning Rate:%.6f&quot; % learn_rate, &quot;Loss:&quot;, loss1) print(&quot;Accuracy:%.2f&quot; % precision, &#x27;%&#x27;) train_record.append([n + 1, loss1, precision]) break if n % 10 == 0: # 每10轮保存一次模型结果 save_model(savepath, w1, w2, w3, b1, b2, b3) print(&quot;Epoch:&quot;, n + 1, &quot;| Learning Rate:%.4f&quot; % learn_rate, &quot;Loss:&quot;, loss1) print(&quot;Accuracy:%.2f&quot; % precision, &#x27;%&#x27;) train_record.append(precision)end_time = time.perf_counter() - start_timeprint(&quot;训练完成！ 最终准确率为：%.2f&quot; % (train_record[-1]), &#x27;%&#x27;, &quot; | 总训练时间为 ： %.3f s&quot; % end_time)# 5. 训练结果可视化# 5.1 训练集loss可视化def plot_train_record(train_record): plt.figure() plt.plot(train_record) plt.xlabel(&#x27;epoch&#x27;) plt.ylabel(&#x27;precision&#x27;) plt.show()# 5.2 随机抽取9张测试集图片进行可视化，观察训练模型的准确率def result_show(): t_x, t_y = data_transpose(test_x, test_y) # 数据集转置 # model_path = &#x27;weight4.h5&#x27; # 可以测试指定模型 # w1, w2, w3, b1, b2, b3 = get_model(model_path) fig, ax = plt.subplots(nrows=3, ncols=3, figsize=(10, 10)) # 生成3 * 3 的子图 ax = ax.flatten() for i in range(9): a = random.randint(0, 9999) # 随机抽取10000个测试集图片中的任意一张 x = np.array(t_x[a]) x = x.reshape(1, width_input) # 输入图片reshape a1 = feedforward(x, w1, b1) # 进行向前传播，计算预测结果 a2 = feedforward(a1, w2, b2) y = feedforward(a2, w3, b3) predict_label = np.argmax(y, axis=1) # 获取预测结果 ax[i].imshow(test_x[a], cmap=&quot;gray&quot;) # 图片显示 ax[i].set_title(&quot;(%d) T: %d P: %d&quot; % (i+1, test_y[a], predict_label)) # 将测试结果与正确结果进行可视化对比 ax[i].set_xticks([]) # 删除坐标 ax[i].set_yticks([]) # 删除坐标 plt.axis(&#x27;off&#x27;) plt.show() plot_train_record(train_record) # 训练过程可视化result_show() # 对结果进行随机检验 4. 结果分析4.1 参数设置​ 在训练过程中，我首先设置了网络的基本参数及训练过程中的超参数。 ​ 对于网络架构，我设置第一层的节点数为784（即28*28输入），第二层的节点数为100.第三层的节点数为100，输出层的节点数为10，前几层的激活函数选用Sigmoid，最后一层为SoftMax ​ 对于训练过程的超参数，由于我们的模型没有采用mini-batch的训练方法，每一个epoch训练的都是全部数据，因此epoch的数量可以设置的相对较小。过几次测试，模型在第8个epoch左右基本收敛，因此设置Epoch为15；采用基础的梯度下降；初始的学习率设置为0.01；选用实验过程一节中提到的第一种学习率更新方法，不采用迁移学习。 ​ 由于训练时间较长，为了清楚当前时刻模型的训练过程及进度，我为训练过程添加了进度条。 4.2 训练过程 上图展示了训练过程中准确率的变化过程。可以很明显地发现，在第8个epoch左右，模型的准确率基本保持97%左右不再变化。经过几次测试，设置epoch为15，在多次测试之后发现，模型都能在训练15个epoch之后达到97%以上的准确度，表明我们设置的网络基本参数以及训练过程的超参数基本合理，可以基本保证模型取得较高的准确率和结果。 上图展示了训练过程及训练结果，经过15个epoch的训练过程，最终取得了97.64%准确率的结果。 4.3 训练结果 上图展示了我们随机抽取9张测试集图片进行预测的结果。T为其真实值（即Truth），P为其预测值（即Predict），结合图片，我们可以发现模型对于随机抽取的9张图片都取得了正确的预测结果，与最终得到的97.64%相对吻合。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://47.118.73.148/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://47.118.73.148/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"Git笔记","slug":"git笔记","date":"2022-03-15T15:39:44.000Z","updated":"2022-03-24T14:52:37.481Z","comments":true,"path":"2022/03/15/git笔记/","link":"","permalink":"http://47.118.73.148/2022/03/15/git%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1. Git 简介Git采用分布式版本控制，每个人都拥有全部的代码。所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。 2. Git 基本原理Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域 Workspace：工作区，就是你平时存放项目代码的地方 Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。 WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。 .git：存放Git管理信息的目录，初始化仓库的时候自动创建。 Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。 Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。 Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。 工作流程 git的工作流程一般是这样的： １、在工作目录中添加、修改文件； ２、将需要进行版本管理的文件放入暂存区域； ３、将暂存区域的文件提交到git仓库。 文件的四种状态 版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 ! Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodified状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified 3. Git 常用命令 创建全新的仓库，需要用GIT管理的项目的根目录执行： $ git init #新建代码库 克隆一个远程仓库 $ git clone [url] 查看文件状态 # 查看指定文件状态git status [filename]# 查看所有文件状态git status 改变文件状态 # 将所有文件添加到暂存区git add . # 提交暂存区的内容到本地仓库 -m 提交消息（一般为代码修改内容，改动情况） git commit -m &quot;消息内容&quot; 4. 忽略文件有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等在主目录下建立”.gitignore”文件，此文件有如下规则： 忽略文件中的空行或以井号（#）开始的行将会被忽略。 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 *.txt #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt #但lib.txt除外/temp #仅忽略项目根目录下的TODO文件,不包括其它目录tempbuild/ #忽略build/目录下的所有文件doc/*.txt #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 5. Git 分支如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！ master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 3. Git 常用命令 创建全新的仓库，需要用GIT管理的项目的根目录执行： $ git init #新建代码库 克隆一个远程仓库 $ git clone [url] 查看文件状态 # 查看指定文件状态git status [filename]# 查看所有文件状态git status 改变文件状态 # 将所有文件添加到暂存区git add . # 提交暂存区的内容到本地仓库 -m 提交消息（一般为代码修改内容，改动情况） git commit -m &quot;消息内容&quot; 4. 忽略文件有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等在主目录下建立”.gitignore”文件，此文件有如下规则： 忽略文件中的空行或以井号（#）开始的行将会被忽略。 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 #为注释*.txt #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt #但lib.txt除外/temp #仅忽略项目根目录下的TODO文件,不包括其它目录tempbuild/ #忽略build/目录下的所有文件doc/*.txt #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 5. Git 分支如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！ master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 3. Git 常用命令 创建全新的仓库，需要用GIT管理的项目的根目录执行： $ git init #新建代码库 克隆一个远程仓库 $ git clone [url] 查看文件状态 # 查看指定文件状态git status [filename]# 查看所有文件状态git status 改变文件状态 # 将所有文件添加到暂存区git add . # 提交暂存区的内容到本地仓库 -m 提交消息（一般为代码修改内容，改动情况） git commit -m &quot;消息内容&quot; 4. 忽略文件有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等在主目录下建立”.gitignore”文件，此文件有如下规则： 忽略文件中的空行或以井号（#）开始的行将会被忽略。 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 #为注释*.txt #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt #但lib.txt除外/temp #仅忽略项目根目录下的TODO文件,不包括其它目录tempbuild/ #忽略build/目录下的所有文件doc/*.txt #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 5. Git 分支如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！ master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 # 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]# 更新更新远程仓库代码到本地分支$ git pull &lt;远程库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;# 例子 ：$ git pull orgin ha ： ha# 撤销对刚pull的分支的改动$ git checkout .# commit后 想撤销，退回上一次commit的版本$ git reset --hard HEAD^","categories":[{"name":"笔记","slug":"笔记","permalink":"http://47.118.73.148/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Git","slug":"git","permalink":"http://47.118.73.148/tags/git/"}]},{"title":"改进的梯度下降法","slug":"梯度下降法","date":"2022-03-15T13:04:10.000Z","updated":"2022-03-15T15:16:59.706Z","comments":true,"path":"2022/03/15/梯度下降法/","link":"","permalink":"http://47.118.73.148/2022/03/15/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/","excerpt":"","text":"改进的梯度下降法1. 摘要梯度下降是目前最流行的优化算法之一，也是当下Machine Learning和 Deep Learning中最常用的优化算法。目前，每一个流行的深度学习库都包含有关梯度下降的方法。梯度下降法是一种一阶优化算法。这意味着它在对参数执行更新时只考虑一阶导数。在每次迭代中，更新与目标函数*J(w)*的梯度相反方向的参数，其中梯度给出了最陡上升的方向。通过设置固定的步长（即学习率），使其沿着梯度方向下降，直至达到局部最小值。然而，由于各种原因，梯度下降法存在一定缺陷，使其在某些场景下无法具有较好的计算效率或准确性。针对这些缺陷，许多科学家提出了改进方法，让改进后的梯度下降法能够具有更好的优化效果。 2. 最速下降法在介绍改进的梯度下降法之前，让我们先回顾最基本的最速下降法，这有助于使我们理解它的缺陷以及改进的角度。 2.1 原理 如果函数 F(x) 在点 a 处可微且有定义，那么函数 F(x) 在 a 沿着与梯度相反的方向 -▽F(a) 下降最多。因此，如果对于 γ &gt; 0 在一个极小值时成立，那么$${ \\displaystyle F(\\mathbf {a} )\\geq F(\\mathbf {b} ) }$$考虑到这一点，我们可以从函数 F 的局部极小值的初始估计出x0发，并考虑如下序列x0, x1, x2….使$${ {x}_{n+1}={x}_n-\\gamma_n \\nabla F({x}_n),\\ n \\ge 0 }$$ 因此可得到 $$F( {f {x} } _ {0}\\geq F( {f {x} } _ {1})\\geq F({f {x} } _ {2})\\geq ….$$ 如果顺利的话序列 Xn 收敛到期望的局部极小值。上方的图片展示了这一过程。 2.2 代码实现class BatchGradientDescent: def __init__(self, eta=0.01, n_iter=1000, tolerance=0.001): self.eta = eta self.n_iter = n_iter self.tolerance = tolerance def fit(self, X, y): n_samples = len(X) X = np.c_[np.ones(n_samples), X] # 增加截距项 n_features = X.shape[-1] self.theta = np.ones(n_features) self.loss_ = [0] self.i = 0 while self.i &lt; self.n_iter: self.i += 1 errors = X.dot(self.theta) - y loss = 1 / (2 * n_samples) * errors.dot(errors) delta_loss = loss - self.loss_[-1] self.loss_.append(loss) if np.abs(delta_loss) &lt; self.tolerance: break else: gradient = 1 / n_samples * X.T.dot(errors) self.theta -= self.eta * gradient return self 3. 改进的梯度下降法虽然最速下降法在最优化上有一定的成效，但我们可以发现，这一方法收敛速度缓慢。且使用固定的学习率，在面对相对稀疏的数据时，并不具有较好的效果。面对这些问题，更多改进的梯度下降法被提出。其中具有代表性的有Momentum动量法，NAG，Adagrad，RMSProp，Adam和Nadam。在这里，我将逐一介绍这些方法，解释他们的原理，并给出相应的Python代码实现。 3. 1 Momentum动量法3.1.1 原理如果把梯度下降法想象成一个小球从山坡到山谷的过程，那么梯度下降法的小球是这样移动的：从A点开始，计算当前A点的坡度，沿着坡度最大的方向走一段路，停下到B。在B点再看一看周围坡度最大的地方，沿着这个坡度方向走一段路，再停下。确切的来说，这并不像一个球，更像是一个正在下山的盲人，每走一步都要停下来，用拐杖来来探探四周的路，再走一步停下来，周而复始，直到走到山谷。而一个真正的小球要比这聪明多了，从A点滚动到B点的时候，小球带有一定的初速度，在当前初速度下继续加速下降，小球会越滚越快，更快的奔向谷底。momentum 动量法就是模拟这一过程来加速神经网络的优化的。 回顾一下梯度下降法每次的参数更新公式：$${W:=W−α∇W}\\ {b : = b − α ∇ b}$$可以看到，每次更新仅与当前梯度值相关，并不涉及之前的梯度。而动量梯度下降法则对各个mini-batch求得的梯度▽w, ▽b使用指数加权平均得到 V_▽w，V_ ▽b，并使用新的参数更新之前的参数例如，在100次梯度下降中求得的梯度序列为:$${ ∇ W 1 , ∇ W 2 , ∇ W 3 . . . . . . . . . ∇ W 99 , ∇ W 100 }$$则其对应的动量梯度分别为：$$V_{\\nabla W_0} = 0$$ $$V_{\\nabla W_1} = \\beta V_{\\nabla W_0} + (1-\\beta)\\nabla W_1$$ $$V_{\\nabla W_2} = \\beta V_{\\nabla W_1} + (1-\\beta)\\nabla W_2$$ $$. .\\.\\. .\\.\\. .\\.\\$$ $$V_{\\nabla W_{100}} = \\beta V_{\\nabla W_{99}} + (1-\\beta)\\nabla W_{100}$$ 使用指数加权平均之后梯度代替原梯度进行参数更新。因为每个指数加权平均后的梯度含有之前梯度的信息，动量梯度下降法因此得名。因此，我们可以得到Momentum动量法的公式：$$V_{dW} = \\beta V_{dW} + (1-\\beta) dW\\V_{db} = \\beta V_{db} + (1 - \\beta) db$$ 3.1.2 优点 上图展示了Momentum动量法的SGD和没有采用Momentum法的SGD的对比，右图为采用Momentum法的结果。 通过这一图片，我们可以明显感受到Momentum动量法的优点。动量法通过用过去梯度的平均值来替换梯度，减少了震荡并大大加快了收敛速度 3.1.3 代码实现class MomentumGradientDescent(MiniBatchGradientDescent): def __init__(self, gamma=0.9, **kwargs): self.gamma = gamma # 当gamma=0时，相当于小批量随机梯度下降 super(MomentumGradientDescent, self).__init__(**kwargs) def fit(self, X, y): X = np.c_[np.ones(len(X)), X] n_samples, n_features = X.shape self.theta = np.ones(n_features) self.velocity = np.zeros_like(self.theta) self.loss_ = [0] self.i = 0 while self.i &lt; self.n_iter: self.i += 1 if self.shuffle: X, y = self._shuffle(X, y) errors = [] for j in range(0, n_samples, self.batch_size): mini_X, mini_y = X[j: j + self.batch_size], y[j: j + self.batch_size] error = mini_X.dot(self.theta) - mini_y errors.append(error.dot(error)) mini_gradient = 1 / self.batch_size * mini_X.T.dot(error) self.velocity = self.velocity * self.gamma + self.eta * mini_gradient self.theta -= self.velocity loss = 1 / (2 * self.batch_size) * np.mean(errors) delta_loss = loss - self.loss_[-1] self.loss_.append(loss) if np.abs(delta_loss) &lt; self.tolerance: break return self 3.2 NAG3.2.1 原理NAG的全称是Nesterov Accelerated Gradient。NAG与Momentum动量法的方法非常相似，二者的差异主要在于计算梯度时所用的参数，一个是纯粹的θ，一个是经过速度调整后的~θ。为了便于理解其内在的差异，可以这样想象二者的作用机制：动量梯度下降是利用历史情况对当前状态进行纠偏，防止过度反应；而Nesterov加速下降则依赖于先见之明，对未来的走势进行预判，在事情发生前便进行了内部调整，避免出现极端情况。再给个不太恰当的比喻，Momentum是亡羊补牢，Nesterov是未雨绸缪。 Nesterov加速梯度下降相比于动量梯度下降的区别是，通过使用未来梯度来更新动量。即将下一次的预测梯度$$\\nabla_\\theta J(\\theta-\\eta\\cdot m)$$考虑进来。其更新公式如下：$$\\gamma\\cdot m+\\eta\\cdot\\nabla_\\theta J(\\theta-\\gamma\\cdot m)$$ $$\\theta := \\theta - m$$ 对于起始点应用动量梯度下降，首先求得在该点处的带权梯度η*▽1 ，通过与之前动量 γ*m矢量加权，求得下一次的θ位置。对于起始点应用Nesterov加速梯度下降，首先通过先前动量求得的预测θ位置，再加上预测位置的带权梯度 γ*m 3.2.2 优点 相对于动量梯度下降法，因为NAG考虑到了未来预测梯度，收敛速度更快。并且当更新幅度很大时，NAG可以抑制震荡。例如起始点在最优点的左侧， γ*m 对应的值在最优点的右侧，对于动量梯度而言，叠加 η*▽1使得迭代后的点更加远离最优点。而NAG首先跳到 γ*m对应的值，计算梯度为正，再叠加反方向的 η*▽2 ，从而达到抑制震荡的目的。 3.2.3 代码实现class NesterovAccelerateGradient(MomentumGradientDescent): def __init__(self, **kwargs): super(NesterovAccelerateGradient, self).__init__(**kwargs) def fit(self, X, y): X = np.c_[np.ones(len(X)), X] n_samples, n_features = X.shape self.theta = np.ones(n_features) self.velocity = np.zeros_like(self.theta) self.loss_ = [0] self.i = 0 while self.i &lt; self.n_iter: self.i += 1 if self.shuffle: X, y = self._shuffle(X, y) errors = [] for j in range(0, n_samples, self.batch_size): mini_X, mini_y = X[j: j + self.batch_size], y[j: j + self.batch_size] error = mini_X.dot(self.theta - self.gamma * self.velocity) - mini_y errors.append(error.dot(error)) mini_gradient = 1 / self.batch_size * mini_X.T.dot(error) self.velocity = self.velocity * self.gamma + self.eta * mini_gradient self.theta -= self.velocity loss = 1 / (2 * self.batch_size) * np.mean(errors) delta_loss = loss - self.loss_[-1] self.loss_.append(loss) if np.abs(delta_loss) &lt; self.tolerance: break return self 3.3 Adagrad3.3.1 原理我们知道，超参数一直以来都是是困扰神经网络训练的问题之一，因为这些参数不可通过常规方法学习获得。而Adagrad就是通过自适应调整学习率的方式，来实现对梯度下降法的优化。Adagrad的全称是Adaptive Gradient Descent，即自适应的梯度下降。 在传统的方法中，对于每一个参数 θ 的训练都使用了相同的学习率α。Adagrad能够在训练中自动的对学习率进行调整，对于出现频率较低参数采用较大的α更新；相反，对于出现频率较高的参数采用较小的α更新。具体来说，每个参数的学习率会缩放各参数反比于其历史梯度平方值总和的平方根。因此，Adagrad非常适合处理稀疏数据。 Adagrad在每轮训练中对每个参数 θi 的学习率进行更新，参数更新公式如下： $$\\Theta_{t+1,i} =\\Theta_{t,i}- \\frac{\\alpha}{\\sqrt{G_{t,ii}+\\epsilon }}\\cdot g_{t,i}$$其中 Gt 为对角矩阵，每个对角线位置 i, i 为对应参数θ从第1轮到第t轮梯度的平方和。ϵ是平滑项，用于避免分母为0，一般取值1e−8$$G _ {j,j}=\\sum _ { \\tau =1 } ^ { t } g _ {\\tau ,j }^{2 }$$ 3.3.2 优点 无需手动调节学习率，通过自适应调整学习率，Adamgrad在处理稀疏数据时具有优势。 3.3.3 代码实现class AdaptiveGradientDescent(MiniBatchGradientDescent): def __init__(self, epsilon=1e-6, **kwargs): self.epsilon = epsilon super(AdaptiveGradientDescent, self).__init__(**kwargs) def fit(self, X, y): X = np.c_[np.ones(len(X)), X] n_samples, n_features = X.shape self.theta = np.ones(n_features) self.loss_ = [0] gradient_sum = np.zeros(n_features) self.i = 0 while self.i &lt; self.n_iter: self.i += 1 if self.shuffle: X, y = self._shuffle(X, y) errors = [] for j in range(0, n_samples, self.batch_size): mini_X, mini_y = X[j: j + self.batch_size], y[j: j + self.batch_size] error = mini_X.dot(self.theta) - mini_y errors.append(error.dot(error)) mini_gradient = 1 / self.batch_size * mini_X.T.dot(error) gradient_sum += mini_gradient ** 2 adj_gradient = mini_gradient / (np.sqrt(gradient_sum + self.epsilon)) self.theta -= self.eta * adj_gradient loss = 1 / (2 * self.batch_size) * np.mean(errors) delta_loss = loss - self.loss_[-1] self.loss_.append(loss) if np.abs(delta_loss) &lt; self.tolerance: break return self 3.4 RMSProp3.4.1 原理Adagrad存在一个缺点，在训练的中后期，分母上梯度平方的累加将会越来越大，从而梯度趋近于0，使得训练提前结束。针对这个缺点，Geoff Hinton 提出了自适应学习率方法——RMSProp。RMSdrop的全称是Root mean square prop，Adagrad会累加之前所有的梯度平方，而RMSProp采用了对历史梯度的平方和进行指数加权移动，来减缓梯度的累积效应，因此可缓解Adagrad算法学习率下降较快的问题。 首先，根据均方计算平均$$E[g^2]_t=0.9E[g^2]_t−1+0.1g^2_t$$ 公式为$$\\Theta _ {t+1} =\\Theta _ {t}- \\frac{\\alpha} {\\sqrt{E[g^2] _ t+\\epsilon } }\\cdot g _ {t}$$ 3.4.2 优点 RMSProp采用完全自适应全局学习率，有利于消除了摆动幅度大的方向，用来修正摆动幅度，使得各个维度的摆动幅度都较小。另一方面使算法具有更好的加速效果，加快了收敛速度。 3.4.3 代码实现class RMSProp(MiniBatchGradientDescent): def __init__(self, gamma=0.9, epsilon=1e-6, **kwargs): self.gamma = gamma self.epsilon = epsilon super(RMSProp, self).__init__(**kwargs) def fit(self, X, y): X = np.c_[np.ones(len(X)), X] n_samples, n_features = X.shape self.theta = np.ones(n_features) self.loss_ = [0] gradient_exp = np.zeros(n_features) self.i = 0 while self.i &lt; self.n_iter: self.i += 1 if self.shuffle: X, y = self._shuffle(X, y) errors = [] for j in range(0, n_samples, self.batch_size): mini_X, mini_y = X[j: j + self.batch_size], y[j: j + self.batch_size] error = mini_X.dot(self.theta) - mini_y errors.append(error.dot(error)) mini_gradient = 1 / self.batch_size * mini_X.T.dot(error) gradient_exp = self.gamma * gradient_exp + (1 - self.gamma) * mini_gradient ** 2 gradient_rms = np.sqrt(gradient_exp + self.epsilon) self.theta -= self.eta / gradient_rms * mini_gradient loss = 1 / (2 * self.batch_size) * np.mean(errors) delta_loss = loss - self.loss_[-1] self.loss_.append(loss) if np.abs(delta_loss) &lt; self.tolerance: break return self 3.5 Adam3.5.1 原理在上文我们有提到Momentum动量法和RMSProp两种方法，一种使用类似于物理中的动量来累积梯度，另一种使得收敛速度更快同时使得波动的幅度更小。那么将两种算法结合起来所取得的表现一定会更好。因此，Adam算法被提出。Adam的全称是 Adaptive Moment Estimation ，它将Momentum算法和RMSProp算法相结合。 Adam利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率。它的公式如下$${m_t=\\beta_1 m_{t-1}+(1-\\beta_1)g_t}$$ $${v_t=\\beta_2v_{t-1}+(1-\\beta_2)g_t^2}$$ $${\\hat{m}_t=\\frac{m_t}{1-\\beta_1^t}}$$ $${\\hat{v}_t=\\frac{v_t}{1-\\beta_2^t}}\\$$ $${\\Theta_{t+1} =\\Theta_{t}- \\frac{\\alpha}{\\sqrt{\\hat{v}_t }+\\epsilon }\\hat{m}_t}$$ 其中，Mt ，Vt 分别是对梯度的一阶矩估计和二阶矩估计，可以看作对期望 E[gt], E[gt^2] 的近似；Mt_hat, Vt_hat是对 Mt, Vt 的校正，这样可以近似为对期望的无偏估计。 Adam算法的提出者建议 β1 的默认值为0.9，β2 的默认值为 0.999，epsilon 默认为 1e-8 Adam相对于RMSProp新增了两处改动。其一，Adam使用经过指数移动加权平均的梯度值来替换原始的梯度值；其二，Adam对经指数加权后的梯度值 Mt 和平方梯度值 都 Vt 进行了修正，亦即偏差修正。 3.5.2 优点 Adam通过结合Momentum动量法和RMSPorp法，在优化问题上具有优秀的性能。它具备高效的计算，更少的内存需求，且在面对稀疏数据时也能取得较好的效果。Adam对目标函数没有平稳要求，即loss function可以随着时间变化。除此之外，Adam能较好的处理噪音样本，并且天然具有退火效果 3.5.3 代码实现class AdaptiveMomentEstimation(MiniBatchGradientDescent): def __init__(self, beta_1=0.9, beta_2=0.999, epsilon=1e-6, **kwargs): self.beta_1 = beta_1 self.beta_2 = beta_2 self.epsilon = epsilon super(AdaptiveMomentEstimation, self).__init__(**kwargs) def fit(self, X, y): X = np.c_[np.ones(len(X)), X] n_samples, n_features = X.shape self.theta = np.ones(n_features) self.loss_ = [0] m_t = np.zeros(n_features) v_t = np.zeros(n_features) self.i = 0 while self.i &lt; self.n_iter: self.i += 1 if self.shuffle: X, y = self._shuffle(X, y) errors = [] for j in range(0, n_samples, self.batch_size): mini_X, mini_y = X[j: j + self.batch_size], y[j: j + self.batch_size] error = mini_X.dot(self.theta) - mini_y errors.append(error.dot(error)) mini_gradient = 1 / self.batch_size * mini_X.T.dot(error) m_t = self.beta_1 * m_t + (1 - self.beta_1) * mini_gradient v_t = self.beta_2 * v_t + (1 - self.beta_2) * mini_gradient ** 2 m_t_hat = m_t / (1 - self.beta_1 ** self.i) # correction v_t_hat = v_t / (1 - self.beta_2 ** self.i) self.theta -= self.eta / (np.sqrt(v_t_hat) + self.epsilon) * m_t_hat loss = 1 / (2 * self.batch_size) * np.mean(errors) delta_loss = loss - self.loss_[-1] self.loss_.append(loss) if np.abs(delta_loss) &lt; self.tolerance: break return self 3.6 Nadam3.6.1 原理Adam通过结合Momentum和RMSProp获得了优秀的优化效果，成为了当下最流行的梯度下降法之一。而受此启发，在Adam的基础上，加入一阶动量的积累，即结合NAG和Adam，一种新的梯度下降算法——Nadam诞生了。 它的公式如下$$\\theta_{t+1} = \\theta_{t} - \\frac{\\eta}{\\sqrt{\\hat{v_t}}+\\epsilon}(\\beta_1\\hat{m_t}+\\frac{(1-\\beta_1)g_t}{1-\\beta^t_1})$$可以看出，Nadam对学习率有了更强的约束，同时对梯度的更新也有更直接的影响。一般而言，在想使用带动量的RMSprop，或者Adam的地方，大多可以使用Nadam取得更好的效果。 3.6.2 优点 通过加入一阶动量的积累，Nadam对学习率有了更强的约束,同时对梯度的更新也有更直接的影响。一般而言,在想使用带动量的RMSprop或者Adam的地方,大多可以使用Nadam取得更好的效果。 3.6.3 代码实现class Nadam(AdaptiveMomentEstimation): def __init__(self, **kwargs): super(Nadam, self).__init__(**kwargs) def fit(self, X, y): X = np.c_[np.ones(len(X)), X] n_samples, n_features = X.shape self.theta = np.ones(n_features) self.loss_ = [0] m_t = np.zeros(n_features) v_t = np.zeros(n_features) self.i = 0 while self.i &lt; self.n_iter: self.i += 1 if self.shuffle: X, y = self._shuffle(X, y) errors = [] for j in range(0, n_samples, self.batch_size): mini_X, mini_y = X[j: j + self.batch_size], y[j: j + self.batch_size] error = mini_X.dot(self.theta) - mini_y errors.append(error.dot(error)) mini_gradient = 1 / self.batch_size * mini_X.T.dot(error) m_t = self.beta_1 * m_t + (1 - self.beta_1) * mini_gradient v_t = self.beta_2 * v_t + (1 - self.beta_2) * mini_gradient ** 2 m_t_hat = m_t / (1 - self.beta_1 ** self.i) # correction v_t_hat = v_t / (1 - self.beta_2 ** self.i) self.theta -= self.eta / (np.sqrt(v_t_hat) + self.epsilon) * ( self.beta_1 * m_t_hat + (1 - self.beta_1) * mini_gradient / (1 - self.beta_1 ** self.i)) loss = 1 / (2 * self.batch_size) * np.mean(errors) delta_loss = loss - self.loss_[-1] self.loss_.append(loss) if np.abs(delta_loss) &lt; self.tolerance: break return self 4. 不同方法的对比 在上文中，我们介绍了各种改进的梯度下降法，它们针对最速下降法存在的种种问题，提出了不同的改进策略和方法。在此，我们将总结和对比这些方法，了解它们与梯度下降法的区别和优点。 最速下降法只考虑一阶导数，它没有引入动量的概念，因此是最简单的。但它的问题是，它的下降速度很慢，有时会在沟壑的两边持续震荡，即最终得到的会是一个局部最优解。 针对最速下降法的下降速度慢和震荡幅度大的问题，Momentum动量法认为可以在梯度下降的过程中加入惯性。即在下坡时，如果发现坡度大，就利用惯性的特性提高速度。Momentum动量法在最速下降法的基础上引入了一阶动量，一阶动量是各个时刻梯度方向的指数移动平均值，约等于最近 1/(1-β)个时刻的梯度向量和的平均值。也就是说，在 t 时刻下降的方向，不仅由当前点的梯度方向决定，而且由此前累积的下降方向决定。β 一般取0.9，这意味着当前的下降方向主由此前累积的下降方向所决定，在此基础上略微偏向当前时刻的下降方向。通过这一方法降低震幅，加快下降速度。 最速下降法存在的另一个问题是有时会在沟壑的两边持续震荡，即最终得到的会是一个局部最优解。针对这个问题，NAG提出了改进方案。我们知道在时刻 t 的主要下降方向是由累积动量决定的，自己的梯度方向说了也不算，那与其看当前梯度方向，不如先看看如果跟着累积动量走了一步，那个时候再怎么走。通过这一方法，NAG减少了震荡幅度，解决了最速下降法的另一问题。 在最速下降法中，学习率是固定的。因此，我们需要不断调整学习率，这也导致算法经常出现下降过慢或错过最优点的问题。而二阶动量的出现，意味着“自适应学习率”优化算法时代的到来。通过自适应调整学习率，我们可以大幅提升梯度下降法的效果。 Adagrad, RMSProp, Adam 和 Nadam 就是这类算法的代表。其中，Adagrad 依据历史梯度平方和的平方根，自适应地调整学习率的大小，从而获得比最速下降法更好的效果。 但Adagrad也存在一些问题，因为它是单调递增的，导致学习率会单调递减至0，这可能会使得训练过程提前结束，即便后续还有数据也无法学到必要的知识。针对这一缺陷，RMSProp 提出了解决方案——不累积全部历史梯度，而只关注过去一段时间的下降梯度。这就解决了二阶动量持续累积、导致训练过程提前结束的问题。 而Adam和Nadam则是对之前几种方法的结合，综合了几种方法的优点，获得了更好的效果。Adam 就是在 RMSprop 的基础上结合了Momentum动量法并加入修正误差，随着梯度变的稀疏，Adam 比 RMSprop 效果会好。 5. 总结在最速下降法提出之后，不断有学者针对该方法提出改进和迭代。通过上文可以看出，许多的算法的提出都是针对前一种方法存在的缺陷进行优化和改进。不同的梯度下降法具有各自侧重点，在解决不同问题时具有各自的优越性。很难说哪一种算法具有远超其他算法的效果，往往需要我们在搭建不同模型，处理不同问题时有针对性地选择合适的算法。相对来说，Adam和Nadam这两种梯度下降方法，在目前最为流行。对于绝大多数情况，Adam和Nadam可以取得较好的效果。 如果数据是稀疏的，就用自适用方法，即 Adagrad, RMSprop, Adam 和 Nadam。RMSprop, Adam 和 Nadam 在很多情况下的效果是相似的。整体来讲，Adam和Nadam 是最好的选择。以往很多论文里都会用最速下降法，没有考虑动量的引入。最速下降法虽然能达到极小值，但是比其它算法用的时间长，而且可能会被困在鞍点。如果需要更快的收敛，或者是训练更深更复杂的神经网络，需要用一种自适应的算法。 在流行的深度学习框架如Pytorch, Tensorflow中，都内置了这些梯度下降算法。因此，在模型搭建过程中，我们只需一行代码就可以快速地部署相应的梯度下降算法。 6. 参考文献 An overview of gradient descent optimization algorithms Sebastian Ruder Ning Qian. (1999). On the momentum term in gradient descent learning algorithms, Neural Networks, Volume 12, Issue 1 Sutskever, I., Martens, J., Dahl, G. &amp; Hinton, G.. (2013). On the importance of initialization and momentum in deep learning. John Duchi, Elad Hazan, Yoram Singer. (2011). Adaptive Subgradient Methods for Online Learning and Stochastic Optimization. 12(61):2121−2159. Geoff Hinton. (2012). Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude Diederik P. Kingma, Jimmy Ba. (2015). Adam: A Method for Stochastic Optimization Ruder, S. (2016). An overview of gradient descent optimization algorithms. arXiv preprint arXiv:1609.04747. Bengio, Y., Boulanger-Lewandowski, N., &amp; Pascanu, R. (2012). Advances in Optimizing Recurrent Networks. https://zhuanlan.zhihu.com/p/77380412?utm_source=wechat_session https://towardsdatascience.com/10-gradient-descent-optimisation-algorithms-86989510b5e9 Dozat, T. (2016). Incorporating Nesterov Momentum into Adam. ICLR Workshop, (1), 2013–2016","categories":[{"name":"笔记","slug":"笔记","permalink":"http://47.118.73.148/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://47.118.73.148/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java-notes","slug":"JAVA-Notes","date":"2021-12-04T12:22:16.000Z","updated":"2021-12-04T13:28:52.564Z","comments":true,"path":"2021/12/04/JAVA-Notes/","link":"","permalink":"http://47.118.73.148/2021/12/04/JAVA-Notes/","excerpt":"","text":"Java-notes课内部分Chapter-1（Java 概述） Java技术的通用性、高效性、平台移植性和安全性，使之成为网络计算的理想技术 Java语言是一种高级编程语言，它具有简单、结构中立、面向对象、可移植、分布式、高性能、多线程、健壮、动态、安全等特点 Chapter-2 （Java基础） 标识符：为程序中的各个元素进行命名，这种命名的记号，就是标识符（Identifier） 标识符规则：在Java 中标识符是以字母、下划线（_）、美元符号（$）等开始的一个字符序列，不能包含运算符和一些特殊字符，如#、*等 关键字：Java中所有的关键字都为小写，不允许对关键字赋予其他含义 变量与常量： 变量的命名： int i; public int j; 常量的命名：final int k = 1; 变量的邻近原则：若在一个作用域中，如果有多个同名的变量可以访问，则按照“邻近”原则，在当前域中定义的变量隐藏其它同名的变量。 数据类型： 数据类型 所占位数 数的范围 byte 8 -27 ~ (27-1) short 16 -215 ~ (215-1) int 32 -231 ~ (231-1) long 64 -263 ~ (263-1) 运算符： “%”（求模运算符）的操作数可为浮点数, 如 52.3%10=2.3 “+” 运算符可用作连接字符串；如果一个操作数是非字符串，其他操作数会自动转化为字符串，如 String s; s=”s:”+6*5 Chapter-3（数组） 数组的创建： Step1 定义数组 ：数组元素类型 数组名[ ] 如 int num_array[]; Step2 生成数组 ：数组名=new 数组元素类型[数组长度] 如 num_array = new int[5]; Step3 初始化数组 ：使数组中的各个元素有确定的数值 如 num_array[1] = 15; 或直接将内存分配放在一个语句中： int num_array[] = &#123;0, 1, 2&#125;; Java定义数组时，不会为数组分配存储空间 Arrays类：Arrays类提供了多个操作数组的静态方法 binarySearch(type[] a,type key)：使用二分搜索法在数组a中搜索指定值key equals(type[] a,type[] b)：比较两个数组是否相等 sort(type[] a)：对数组a进行排序(默认升序) fill (type[] a, type val)：用一个指定的值val填充数组a 例：Arrays.sort(num_array); Chapter-4（类和对象设计） 面向对象基础 多态：类中同一名称的行为（方法）可以有多种不同的功能，或者相同的接口有多种实现方法。 用户必须先定义类，并生成该类的实例，然后才能通过该实例访问其成员变量和方法。 格式： [类修饰符] class 类名 [extends 父类名] [implements 接口名] { //类体，包括定义类的成员变量 和 成员方法 } 包（package）：package语句必须是程序的第一条非空格、非注释语句；同一个包中，类不可以重名，但是不同的包中允许相同的类名出现 格式：package pkg1[．pkg2[．pkg3…]]; import： pkg1.pkg2.* （*可以导入pkg2中所有的类） import static: 用于导入指定类的某个静态成员变量 / 方法 / 或全部静态成员变量 / 方法（例如可以直接导入Math类中的变量PI） 修饰符： Public: 使用public，意味着public之后的成员声明对每个人都是有用的；修饰类时，一个类中最多只能有一个public，且类名需要与文件名相同 Private: 即便是处于同一个包内的其他类也是不可以访问private成员的，通俗说就是自己隔离了自己 Protected: protected处理的是继承的概念。只有继承他的类才可以访问他的方法（与public的区别是，只有同一个包中的类才可以访问） Default: 如果类成员前没有使用public,protected,private中的任何一个修饰符，我们称它使用了缺省(default)修饰符；只有该类本身以及与该类在同一个包中的其它类才可以直接访问这些缺省成员（与protected的区别是，不同包中的子类不可以访问） Final: 修饰类时：不可被继承； 修饰方法时，不可被重写，可以被继承； 修饰引用时，若为基本数据类型，则为常量，不可修改；若为引用数据类型，则地址不可修改，对象本身的属性可以修改 final int[] {1, 3, 2}; arr[2] = 4; arr = new int[] {12341};（不可修改地址） Static: 可以在没有创建对象的情况下来进行调用（方法/变量） 修饰方法时：静态方法，可以在没有创建对象的情况下来进行调用（方法/变量），不依附于任何对象，因此没有this；静态方法不可以访问成员的非静态方法/变量；非静态方法可以访问静态方法/变量 修饰变量时：静态变量，静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响 修饰代码块时：用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次 static { //代码块（只会在类加载的时候执行一次） } 注意⚠️：Java中的static不可以用于修饰局部变量；static不改变成员的访问权限（只受public private protected影响） Chapter-5 （继承与多态） 继承：Java只支持单继承，即只能有一个父类，但类之间的继承可以具有传递性；子类可以通过继承获得父类中除访问权限为private的成员变量和方法 格式： class 子类名 extends 父类名{ 类体 } 重写（override）：在类的继承过程中，如果子类中新增的变量和方法与父类中的变量和方法同名，则称为重写（或覆盖）；方法重写不仅要求父类与子类中的方法名称相同，而且参数列表也要相同，只是实现的功能不同 super： 用来引用当前对象的父类，可以使用它访问父类中被覆盖的成员 格式：super.method 调用父类中的某一个构造函数（应该为构造函数中的第一条语句）；若类没有任何构造方法，编译器会自动添加一个无参构造方法，在此方法中只有一条语句super()，若已有有参的构造方法，则不会自动添加 格式：super(参数); this：是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针 普通的直接引用，this 相当于是指向当前对象本身 形参与成员名字重名，用 this 来区分： public int GetAge(int age){ ​ this.age = age; return this.age; //这里 age 是 GetAge 成员方法的形参，this.age 是 Person 类的成员变量 } 引用构造函数；调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句） 格式：this(参数); 注意⚠️：this和 super都指的是对象，所以，均不可以在 static 环境中使用 类型转换 如果是子类对象转换为父类，可进行显式转换或隐式转换： Dad = (father) A Child = (child) B //显式转换 如果是父类对象转换成子类，编译器首先要检查这种转换的可行性，如果可行，则必须进行显式转换 多态：多态性就是一个名称可以对应多种不同的实现方法；对重写的方法，Java根据调用该方法的实例的类型来决定选择哪个方法（c++需要添加virtual） 抽象类（abstract）：Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口 抽象类不能被实例化，必须被继承；抽象方法只有方法的返回值、名称和参数列表，没有方法体，它必须在子类中具体实现该方法 抽象类没有自己的主体（没有{}包起来的 业务逻辑），跟接口中的方法有点类似。所以没法直接调用抽象方法 抽象类可以比作不同的交通工具有不同的结果，自行车靠骑，汽车靠发动机运行；因此抽象类只是提供一个 交通工具类（），具体到自行车还是汽车，需要被子类所继承/重写；抽象方法也是同理。因此，抽象方法不可以是static或private，因为抽象方法没有主体，且需要权限访问重写 接口（interface）：是一个抽象类型，是抽象方法的集合 接口中的所有方法都是抽象的（可以不写abstract），也没有方法体{}；接口中的所有数据都是静态常量（static,final可以不写） 一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类 接口支持多继承（可以有多个父类） 格式： [可见度] interface 接口名称 [extends 其他的接口名] { ​ // 声明变量 // 抽象方法 } 接口实现：当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类；类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面 格式：...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ... 内部类： 成员内部类：成员内部类是最普通的内部类，它的定义为位于另一个类的内部 员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）; 不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：外部类.this.成员变量/方法； 在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问（需要先new一个内部类） Test outer = new Test(); Test.inner in = outer.new inner(); 局部内部类： 局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内 局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符 匿名内部类： 可以在定义一个类的同时将它实例化，与局部内部类很相似，区别是它没有类名；如果某个类只需要使用一次，则可以选择采用匿名内部类来简化代码。 前提：必须继承一个父类或实现一个接口,然后继承或重写父类或接口中的方法 格式：father name = new father(){ ​ public void xxx{ ​ } ​ }; 静态内部类：静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static 一旦内部类使用static修饰，这个类就为顶级类；除了写在类内部以外，具有外部类的一切特性 静态内部类可以在内部定义static元素，在构建对象时可以一次性完成（非静态需要先new一个外部类） 内部接口自动具有static属性，普通类可以直接实现接口 Lambda表达式：用函数表达式代替常规的代码 特性： 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号 可选的大括号：如果主体包含了一个语句，就不需要使用大括号 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值 语法格式： (parameters) -&gt; expression 或 (parameters) -&gt;{ statements; return;} 可以用lambda表达式代替匿名内部类或Runnable接口 例子： ```javaComparator c = (Person p1, Person p2) -&gt; p1.getAge().compareTo(p2.getAge());- ```java features.forEach(n -&gt; System.out.println(n)); 泛型: 操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法 常见的如T、E、K、V等形式的参数常用于表示泛型 泛型类： 格式：（泛型的类型参数只能是类类型，不能是简单类型） class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123; private 泛型标识 /*（成员变量类型）*/ var; ..... &#125;&#125;//exp:public class Generic&lt;T&gt;&#123; private T key;&#125; 泛型接口: 格式： //定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125; 泛型方法： 泛型方法，是在调用方法的时候指明泛型的具体类型 格式： public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException , IllegalAccessException&#123; T instance = tClass.newInstance(); return instance; 注解：注解就是对于代码中某些鲜活个体的贴上去的一张标签 元注解 元注解是可以注解到注解上的注解，或者说元注解是一种基本注解 元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种 @Retention 它解释说明了这个注解的的存活时间 它的取值如下： RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 @Documented 它的作用是能够将注解中的元素包含到 Javadoc 中去 @Target 指定了注解运用的地方，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景 @Target 有下面的取值 ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @Inherited Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解 注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也将拥有 Test 这个注解 @Repeatable 可重复的意思，标识某注解可以在同一个声明上使用多次 Persons 是一张总的标签，上面贴满了 Person 这种同类型但内容不一样的标签。把 Persons 给一个 SuperMan 贴上，相当于同时给他贴了程序员、产品经理、画家的标签 注解的属性 注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型 赋值的方式是在注解的括号内以 value=”” 形式，多个属性之前用 ，隔开 @&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名1&gt;=&lt;成员值1&gt;,...) 需要注意的一种情况是一个注解没有任何属性 public @interface Perform {} 那么在应用这个注解的时候，括号都可以省略 @Perform Java预置的注解 @Deprecated 这个元素是用来标记过时的元素。编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量 @Override 提示子类要复写父类中被 @Override 修饰的方法 @SuppressWarnings 阻止警告的意思，调用被 @Deprecated 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 @SuppressWarnings 达到目的 @SafeVarargs 参数安全类型注解，它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 unchecked 这样的警告。它是在 Java 1.7 的版本中加入的 @FunctionalInterface 函数式接口注解，这个是 Java 1.8 版本引入的新特性。函数式接口 (Functional Interface) 就是一个具有一个方法的普通接口。 进行线程开发中常用的 Runnable 就是一个典型的函数式接口可以看到它就被 @FunctionalInterface 注解 自定义注解 格式：public @interface 注解名 {定义体} Chapter-6（标准类库） 字符串类： String的构造： String s = new String(“String test”); String s = “String test”; ```javachar temp_box[] = {‘a’, ‘b’, ‘c’}; //数组构造String temp3 = new String(temp_box); 2. 常用方法： - **.length()** 求String长度 - **.equals()** 判断两个字符串是否相同 - **.compareTo()** 长度相同,从第一位开始比较，如果相同返回0，如果不同则马上返回这两个字符的ascii值的差值; 长度不同,直接返回长度差值 - **.indexOf()** 由前向后查找指定字符串位置，如果超找到了则返回（第一个字母）位置索引，如果找不到返回-1 - **.substring(int beginIndex,int endIndex)** 获得的子串是从当前字符串的beginIndex处开始截取到endIndex-1结束所得到的字符串 - **.replaceAll(String old, String new)** 用new字符串替换old字符串 - **.trim()** 用于删除字符串的头尾空白符3. StringBuffer类： - 对字符串进行修改时，需要使用StringBuffer类；StringBuffer类可以多次修改，并且不产生新的未使用对象（因为只对StringBuffer对象本身进行操作）4. StringBuilder类： - StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的；且相较于StringBuffer，有速度优势 - ```java //代码事例： StringBuilder temp = new StringBuilder(10); //capacity = 10 temp.append(&quot;noob..&quot;); temp.insert(3,&quot;a&quot;); 常用方法： .capacity() 返回当前容量 .append(String value) 添加指定字符串到此序列 .insert(int index, String value) 在index处插入字符串value .reverse() 将此字符串用反转形式取代 .delete(int start, int end) 删除 [start,end) 处的字符串 .replace(int start, int end, String value) 使用给定value中的字符替换此序列的子字符串中[start,end)的字符 System类： .currentTimeMillis( ) 返回自1970年1月1日午夜起到现在的时间，时间单位是毫秒 .arraycopy(src, src_start_Pos, dest, dest_start_Pos, length) 可以将一个任意类型的数组快速地从一个地方复制到另一个地方(这比使用Java中编写的循环要快的多);需要注意的是目标数组相对应位置上的元素会被覆盖掉 Runtime类： Runtime r = new Runtime.getRuntime()； r.totalMemory(); r.freeMemory(); 可以用于获取Java虚拟机内部的内存使用 Math类： .nextInt(int n) 返回一个[0,n) 的随机整数 .nextDouble(); .nextLong(); .nextBoolean(); 返回一个随机值 Collection集合类： 主要分为3种：Set、Map和List 面向接口编程，先定义接口，再定义实现类 常用方法： .add(); .remove(); .size(); .toarray(); ArrayList类： Iterator： ArrayList al = new ArrayList(); Iterator it = al.iterator(); Map;HashMap;Set;HashSet;TreeSet类 Chapter-7（异常处理）异常的根类是 Throwable ，异常类可以分为Error和Exception Error Error通常是无法处理的异常，比如OutOfMemoryError，一般发生这种异常，JVM会选择终止程序 Exception Exception是可以处理的异常，比如NullPointerException、IndexOutOfBoundsException；Exception类的异常包括checked exception和unchecked exception（unchecked exception也称运行时异常RuntimeException，当然这里的运行时异常并不是前面所说的运行期间的异常，只是Java中用运行时异常这个术语来表示，Exception类的异常都是在运行期间发生的） unchecked exception（非检查异常） 也称运行时异常（RuntimeException），比如常见的NullPointerException、IndexOutOfBoundsException。对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定 checked exception（检查异常） 也称非运行时异常（运行时异常以外的异常就是非运行时异常），java编译器强制程序员必须进行捕获处理，比如常见的IOExeption和SQLException。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过 异常的处理 Try…catch…finally try&#123; //try块中放可能发生异常的代码 //如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话） //如果发生异常，则尝试去匹配catch块&#125;catch(SQLException SQLexception)&#123; //每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中 //catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常 //在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问 //如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器 //如果try中没有发生异常，则所有的catch块将被忽略&#125;catch(Exception exception)&#123; //如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面&#125;finally&#123; //finally块通常是可选的 //无论异常是否发生，异常是否匹配被处理，finally都会执行 //一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常 //finally主要做一些清理工作，如流的关闭，数据库连接的关闭等&#125; java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。 Throws函数 throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理 如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过 采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责 public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN&#123; //foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象&#125; Throws和Throw throws 是方法可能抛出异常的声明(用在声明方法时，表示该方法可能要抛出异常) 调用者必须做出处理（捕获或继续抛出） public void doA(int a) throws Exception1,Exception3{……} throw 是语句抛出一个异常 throw e; throws可以单独使用，但throw不能， throw要么和try-catch-finally语句配套使用，要么与throws配套使用。但throws可以单独使用，然后再由处理异常的方法捕获 throw语句用在方法体内,表示抛出异常,由方法体内的语句处理 throws语句用在方法声明后面,表示再抛出异常,由调用这个方法的上一级方法中的语句来处理，必须做出处理(捕获或继续声明) throws主要是声明这个方法会抛出这种类型的异常，使其他地方调用它时知道要捕获这个异常，使得提醒必须做出处理。否则编译是不会通过的throw是具体向外抛异常的动作，所以它是抛出一个异常实例 Finally块 finally块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：System.exit()。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。 良好的编程习惯是：在try块中打开资源，在finally块中清理释放这些资源 finally块没有处理异常的能力。处理异常的只能是catch块 在同一try…catch…finally块中 ，如果try中抛出异常，且有匹配的catch块，则先执行catch块，再执行finally块。如果没有catch块匹配，则先执行finally，然后去外面的调用者中寻找合适的catch块 在同一try…catch…finally块中 ，try发生异常，且匹配的catch块中处理异常时也抛出异常，那么后面的finally也会执行：首先执行finally块，然后去外围调用者中寻找合适的catch块 在 try块中即便有return，break，continue等改变执行流的语句，finally也会执行 ⚠️注意： 当子类重写父类的带有 throws声明的函数时，其throws声明的异常必须在父类异常的可控范围内——用于处理父类的throws方法的异常处理器，必须也适用于子类的这个带throws方法 。这是为了支持多态 Java程序可以是多线程的。每一个线程都是一个独立的执行流，独立的函数调用栈。如果程序只有一个线程，那么没有被任何代码处理的异常 会导致程序终止。如果是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束 也就是说，Java中的异常是线程独立的，线程的问题应该由线程自己来解决，而不要委托到外部，也不会直接影响到其它线程的执行 finally和return建议 不要在fianlly中使用return 不要在finally中抛出异常 减轻finally的任务，不要在finally中做一些其它的事情，finally块仅仅用来释放资源是最合适的 将尽量将所有的return写在函数的最后面，而不是try … catch … finally中 Chapter-8（输入输出处理） Java流 标准输入输出，文件的操作，网络上的数据流，字符串流，对象流，zip文件流等等，java中将输入输出抽象称为流，就好像水管，将两个容器连接起来。将数据冲外存中读取到内存中的称为输入流，将数据从内存写入外存中的称为输出流 流是一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流 流按照流向可以分为两种，输入流InputStream和输出流OutputStream 按照处理数据单元可以分为两种，字节流（8位通用字节流）和字符流（16位Unicode字符流） InputStream抽象类 InputStream 为字节输入流，它本身为一个抽象类，必须依靠其子类实现各种功能，此抽象类是表示字节输入流的所有类的超类。 继承自InputStream 的流都是向程序中输入数据的，且数据单位为字节（8bit） Inputstream类中的常用方法： public abstract int read( )：读取一个byte的数据，返回值是高位补0的int类型值。若返回值=-1说明没有读取到任何字节读取工作结束 public int read(byte b[ ])：读取b.length个字节的数据放到b数组中。返回值是读取的字节数。该方法实际上是调用下一个方法实现的 public int read(byte b[ ], int off, int len)：从输入流中最多读取len个字节的数据，存放到偏移量为off的b数组中 public int available( )：返回输入流中可以读取的字节数。注意：若输入阻塞，当前线程将被挂起，如果InputStream对象调用这个方法的话，它只会返回0，这个方法必须由继承InputStream类的子类对象调用才有用 public long skip(long n)：忽略输入流中的n个字节，返回值是实际忽略的字节数, 跳过一些字节来读取 public int close( ) ：我们在使用完后，必须对我们打开的流进行关闭 OutputStream抽象类 OutputStream提供了3个write方法来做数据的输出，这个是和InputStream是相对应的 public void write(byte b[ ])：将参数b中的字节写到输出流。 public void write(byte b[ ], int off, int len) ：将参数b的从偏移量off开始的len个字节写到输出流。 public abstract void write(int b) ：先将int转换为byte类型，把低字节写入到输出流中 public void flush( ) : 将数据缓冲区中数据全部输出，并清空缓冲区 public void close( ) : 关闭输出流并释放与流相关的系统资源 流结束的判断：方法read()的返回值为-1时；readLine()的返回值为null时 文件输入流： FileInputStream类 FileInputStream可以使用read()方法一次读入一个字节，并以int类型返回，或者是使用read()方法时读入至一个byte数组，byte数组的元素有多少个，就读入多少个字节。在将整个文件读取完成或写入完毕的过程中，这么一个byte数组通常被当作缓冲区，因为这么一个byte数组通常扮演承接数据的中间角色 import java.io.File;import java.io.IOException;public class code01 &#123; public static void main(String[] args) throws IOException&#123; File dir = new File(&quot;/Users/calvin/IdeaProjects/test/src/iostream_demon&quot;); File f1 = new File(dir, &quot;code01.java&quot;); System.out.println(f1); System.out.println(&quot;exist :&quot; + f1.exists()); System.out.println(&quot;name :&quot; + f1.getName()); System.out.println(&quot;path :&quot; + f1.getPath()); System.out.println(&quot;absolute path :&quot; + f1.getAbsolutePath()); System.out.println(&quot;parent :&quot; + f1.getParent()); System.out.println(&quot;is a file :&quot; + f1.isFile()); System.out.println(&quot;is a dictionary :&quot; + f1.isDirectory()); System.out.println(&quot;length :&quot; + f1.length()); File temp_file = File.createTempFile(&quot;temp_file01&quot;,&quot;.tmp&quot;); System.out.println(&quot;absolute path :&quot; + temp_file.getAbsolutePath()); System.out.println(&quot;length :&quot; + temp_file.length()); &#125;&#125; 文件输出流:FileOutputStream类 用来处理以文件作为数据输出目的数据流；或者说是从内存区读数据入文件 FileOutputStream类用来处理以文件作为数据输出目的数据流；一个表示文件名的字符串，也可以是File或FileDescriptor对象 //创建一个文件流对象有两种方法： //方式1： File f=new File (“d:/myjava/write.txt &quot;); FileOutputStream out= new FileOutputStream (f); //方式2： FileOutputStream out=new FileOutputStream(“d:/myjava/write.txt &quot;); //方式3：构造函数将 FileDescriptor()对象作为其参数。 FileDescriptor() fd=new FileDescriptor(); FileOutputStream f2=new FileOutputStream(fd); //方式4：构造函数将文件名作为其第一参数，将布尔值作为第二参数。 FileOutputStream f=new FileOutputStream(&quot;d:/abc.txt&quot;,true); //注意： （1）文件中写数据时，若文件已经存在，则覆盖存在的文件；（2）的读/写操作结束时，应调用close方法关闭流 缓冲输入输出流 BufferedInputStream/ BufferedOutputStream 计算机访问外部设备非常耗时。访问外存的频率越高，造成CPU闲置的概率就越大。为了减少访问外存的次数，应该在一次对外设的访问中，读写更多的数据。为此，除了程序和流节点间交换数据必需的读写机制外，还应该增加缓冲机制。缓冲流就是每一个数据流分配一个缓冲区，一个缓冲区就是一个临时存储数据的内存。这样可以减少访问硬盘的次数,提高传输效率 BufferedInputStream:当向缓冲流写入数据时候，数据先写到缓冲区，待缓冲区写满后，系统一次性将数据发送给输出设备 BufferedOutputStream :当从向缓冲流读取数据时候，系统先从缓冲区读出数据，待缓冲区为空时，系统再从输入设备读取数据到缓冲区 将文件读入内存： 将BufferedInputStream与FileInputStream相接 FileInputStream in=new FileInputStream( “file1.txt ” ); BufferedInputStream bin=new BufferedInputStream( in); 将内存写入文件： 将BufferedOutputStream与 FileOutputStream相接 FileOutputStreamout=new FileOutputStream(“file1.txt”); BufferedOutputStream bin=new BufferedInputStream(out); 键盘输入流读到内存 将BufferedReader与标准的数据流相接 InputStreamReader sin=new InputStreamReader (System.in) ； BufferedReader bin=new BufferedReader(sin); //缓冲流实现文件复制public class code02 &#123; public static void main(String[] args) throws IOException &#123; int size; FileInputStream f = new FileInputStream(&quot;/Users/calvin/IdeaProjects/test/src/iostream_demon/code02.java&quot;); FileOutputStream fout = new FileOutputStream(&quot;copy-of-file.txt&quot;); BufferedInputStream bis = new BufferedInputStream(f); BufferedOutputStream bos = new BufferedOutputStream(fout); System.out.println(&quot;Start Copy Process: &quot;); int n = f.available(); byte b[] = new byte[n]; int count = 0; while ((count = bis.read(b, 0, n)) != -1) bos.write(b, 0, n); System.out.println(&quot;Copy End&quot;); bis.close(); bos.flush(); bos.close(); f.close(); fout.flush(); fout.close(); &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://47.118.73.148/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JAVA","slug":"java","permalink":"http://47.118.73.148/tags/java/"}]},{"title":"利用Fake-Location实现代跑","slug":"利用fake-location实现代跑","date":"2021-06-12T17:04:26.000Z","updated":"2022-03-24T14:50:31.950Z","comments":true,"path":"2021/06/13/利用fake-location实现代跑/","link":"","permalink":"http://47.118.73.148/2021/06/13/%E5%88%A9%E7%94%A8fake-location%E5%AE%9E%E7%8E%B0%E4%BB%A3%E8%B7%91/","excerpt":"","text":"利用Fake Location实现代跑大学每学期需要乐跑30次（30 * 3km），而我又是一条懒狗，所以就想到用虚拟定位来代跑。如果碰巧你和我一样也是一条懒狗，那不妨也试试。 目前已知Keep和步道乐跑可以正常用，其他跑步软件没试过，应该没有太大问题。 前期准备需要用到的设备： 一部安卓手机 🧠 具体步骤1.获取root权限 如果你的手机已经root，可以跳到下一步。 由于目前大多数手机root非常麻烦，所以我们选择使用虚拟机来实现这一步骤。 Step1. 下载 VMOS Pro（应用商店里应该都有，没有就去百度上下载） Step2. 进入VMOS Pro，选择一个自带root的ROM，如安卓7.1精简版。带Root的ROM一般需要会员，你可以选择每天看广告用积分白嫖，或是充值会员。 Step3.进入ROM，点击Setting，勾选超级用户选项 Step4. 进入设置（不是Setting），选择关于手机，点击版本号5次，当设备显示“开发者模式已启用”，返回虚拟机桌面 2.下载Fake Location选择桌面底部黄色图标，导入“步道乐跑”、“Fake Location”和QQ Fake Location的下载链接百度上可以找到。 3.配置Fake Location 进入Fake Location 将“步道乐跑”加入反检测和Root隐藏中，并开启反检测和Root隐藏。反检测和Root隐藏需要会员，每月好像是10块钱。 点击路线模拟，点击➕绘制跑步路线，并设置步频和速度（过快或过慢成绩会无效） 启动模拟，并进入步道乐跑，开始跑步，跑完记得关掉。 PS以后每次使用只需按照【3】的步骤，如果VMOS Pro开通会员，每天大约需要15分钟即可完成跑步。不开通会员，看广告白嫖大约需要20分钟。当然，跑步的时候你可以做自己的事情，也就是说真正花费的时间只是【3】中配置的时间，大约需要5分钟。 当然，在大学中适当的体育锻炼还是有必要的，所以请合理使用代跑。","categories":[{"name":"教程","slug":"教程","permalink":"http://47.118.73.148/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"代跑","slug":"代跑","permalink":"http://47.118.73.148/tags/%E4%BB%A3%E8%B7%91/"}]},{"title":"leetcode&洛谷刷题笔记","slug":"leetcode-洛谷刷题笔记","date":"2021-06-07T17:54:30.000Z","updated":"2021-06-13T12:39:31.186Z","comments":true,"path":"2021/06/08/leetcode-洛谷刷题笔记/","link":"","permalink":"http://47.118.73.148/2021/06/08/leetcode-%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1.时间复杂度常数阶O(1)&lt;对数阶O(log2n)&lt;线性阶O(n),&lt;线性对数阶O(nlog2n)&lt;平方阶O(n^2)&lt;方阶O(n3)&lt;k次方阶O(n^k)&lt;指数阶O(2^n)&lt;O(n!)&lt;O(n^n) 2.快读inline int read()&#123; register int s=0,w=1; register char ch=getchar(); while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123; if(ch==&#x27;-&#x27;)&#123; w=-1; ch=getchar(); &#125; &#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123; s=s*10+ch-&#x27;0&#x27;; ch=getchar(); &#125; return s*w;&#125; 3.贪心算法所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。）所以，对所采用的贪心策略一定要仔细分析其是否满足无后效性。 例：背包问题 4.快排快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。 该方法的基本思想是： 1．先从数列中取出一个数作为基准数。 2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 3．再对左右区间重复第二步，直到各区间只有一个数。 //快速排序 传统void quick_sort(int s[], int l, int r)&#123; if (l &lt; r) &#123; //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1 int i = l, j = r, x = s[l]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数 j--; if(i &lt; j) s[i++] = s[j]; while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数 i++; if(i &lt; j) s[j--] = s[i]; &#125; s[i] = x; quick_sort(s, l, i - 1); // 递归调用 quick_sort(s, i + 1, r); &#125;&#125; //洛谷void qsort(int l,int r)//应用二分思想&#123; int mid=a[(l+r)/2];//中间数 int i=l,j=r; do&#123; while(a[i]&lt;mid) i++;//查找左半部分比中间数大的数 while(a[j]&gt;mid) j--;//查找右半部分比中间数小的数 if(i&lt;=j)//如果有一组不满足排序条件（左小右大）的数 &#123; swap(a[i],a[j]);//交换 i++; j--; &#125; &#125; while(i&lt;=j);//这里注意要有= if(l&lt;j) qsort(l,j);//递归搜索左半部分 if(i&lt;r) qsort(i,r);//递归搜索右半部分&#125; nth_element 这个函数主要用来将数组元素中第k小的整数排出来并在数组中就位，随时调用，可谓十分实用。 函数语句：nth_element(数组名,数组名+第k小元素,数组名+元素个数) 5.RMQ算法dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;j-1)][j-1]) 我们设二维数组dp[i][j]表示从第i位开始连续 个数中的最小值。例如dp[2][1]就表示从第二位数开始连续两个数的最小值（也就是从第二位数到第三位数的最小值），即2，6中的最小值，所以dp[2][1] = 2; void rmq_init()&#123; for(int i=1;i&lt;=N;i++) dp[i][0]=arr[i];//初始化 for(int j=1;(1&lt;&lt;j)&lt;=N;j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=N;i++) dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;j-1)][j-1]);&#125; 查询部分： 预处理出整个 dp 数组以后，查询操作很简单，令 k 为满足 2^k&lt;=𝑅−𝐿+12k&lt;=R−L+1 的最大整数，则以 L 开头、以 R 结尾的两个长度为 2^𝑘 的区间合起来即覆盖了查询区间 [L,R] 。 int RMQ(int L,int R)&#123; int k=0; while((1&lt;&lt;(k+1))&lt;=R-L+1) k++; return min(dp[L][k],dp[R-(1&lt;&lt;k)+1][k]);&#125; 6.卡特兰数递推式1： f[n]=f[0]∗f[n−1]+f[1]∗f[n−2]+...+f[n−1]∗f[0](n≥2) 递推式2: h[n]=h[n−1]∗(4∗n−2)/(n+1) 递推式3: h[n]=C[2n,n]/(n+1)(n=0,1,2,...),C是组合数PS: C[m,n]=C[m−1,n−1]+C[m−1,n]且规定： C[n,0]=1 C[n,n]=1 C[0,0]=1 递推式4: h[n]=C[2n,n]−C[2n,n−1](n=0,1,2,...) 7.DP问题建表 得出状态转移方程 //背包问题int main()&#123; int n,m; int price[110]=&#123;&#125;; int a[110][1100]=&#123;&#125;; cin&gt;&gt;n&gt;&gt;m; for (int i=1;i&lt;=n;i++) cin&gt;&gt;price[i]; for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=m;j++)&#123; if ( j == price[i]) a[i][j] = a[i-1][j] + 1; if ( j &lt; price[i]) a[i][j] = a[i-1][j]; if ( j &gt; price[i]) a[i][j] = a[i-1][j] + a[i-1][j-price[i]]; &#125; &#125; cout&lt;&lt;a[n][m]&lt;&lt;endl; return 0;&#125; 8.sort排序const int N =400;struct stu&#123; int c,m,e; int sum; int id;&#125;arr[N];bool cmp( stu a,stu b)&#123; if (a.sum !=b.sum) return a.sum &gt; b.sum; if (a.c != b.c) return a.c &gt; b.c; return a.id &lt; b.id;&#125;int main()&#123; int n; cin&gt;&gt;n; for (int i=1;i&lt;=n;i++)&#123; int a , b, c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; arr[i]=&#123;a,b,c,a+b+c,i&#125;; &#125; sort(arr+1,arr+1+n,cmp); for (int i=1;i&lt;=5;i++)&#123; cout &lt;&lt; arr[i].id &lt;&lt;&quot; &quot;&lt;&lt; arr[i].sum &lt;&lt; endl; &#125; return 0; &#125; sort(begin,end,(###))###不填默认升序 9.二分查找1.STL自带二分函数 函数的用法：lower_bound(a.begin(),a.end(),x) 返回第一个大于等于 xx 的数的地址。而由于是地址，在最后要 −a（也就是减去地址）。 int main()&#123; int n=read(),m=read();//读入 for(int i=1;i&lt;=n;i++) a[i]=read(); while(m--)&#123; int x=read(); int ans=lower_bound(a+1,a+n+1,x)-a;//二分搜，注意-a if(x!=a[ans]) printf(&quot;-1 &quot;);//没有，输出-1 else printf(&quot;%d &quot;,ans);//有，输出ans &#125; return 0;//华丽结束&#125; 10.DFS深度搜索//一般框架void DFS(type n)&#123; //可以描述阶段的状态 if(符合条件) &#123; cout&lt;&lt;答案; return; &#125; //出口 if(可以剪枝) return; //剪枝 for(i:1~p)&#123; //选择该阶段的所有决策 选择可行决策; //剪枝的一种 标记已访问该点; DFS(n+1); //进入下一阶段 (还原访问现场;) &#125;&#125; //连通体判断 - DFS#include &lt;bits/stdc++.h&gt;using namespace std;char arr[105][105]; int fxx[9]=&#123;0,-1,-1,-1,0,0,1,1,1&#125;;//x方向int fxy[9]=&#123;0,-1,0,1,-1,1,-1,0,1&#125;;//y方向int n,m,ans = 0;void dfs(int x,int y)&#123; int r,c; arr[x][y] = &#x27;.&#x27;; for (int i=1;i&lt;=8;i++)&#123; r = x + fxx[i]; c = y + fxy[i]; if (r&lt;1||r&gt;n||c&lt;1||c&gt;m||arr[r][c] == &#x27;.&#x27;) continue; arr[r][c] = &#x27;.&#x27;; dfs(r,c); &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for (int i = 1;i &lt;= n;i++)&#123; for (int j = 1;j &lt;= m;j++)&#123; cin&gt;&gt;arr[i][j]; &#125; &#125; for (int i = 1;i &lt;= n;i++)&#123; for (int j = 1;j &lt;= m;j++)&#123; if (arr[i][j] == &#x27;W&#x27;)&#123; ans++; dfs(i,j); &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0; &#125; //迷宫#include&lt;cstdio&gt;using namespace std;int p,q,min = 9999999;int a[100][100];int v[100][100];int dx[4]=&#123;0,1,0,-1&#125;;int dy[4]=&#123;1,0,-1,0&#125;;void dfs(int x,int y,int step)&#123; if (x==p &amp;&amp; y==q)&#123; if (step&lt;min)&#123; min = step; return; &#125; &#125; for(int k=0;k&lt;=3;k++)&#123; int tx,ty; tx = x + dx[k]; ty = y + dy[k]; if (a[tx][ty] == 1 &amp;&amp; v[tx][ty] == 0)&#123; v[tx][ty] = 1; dfs(tx,ty,step+1); v[tx][ty] = 0; &#125; &#125;&#125;int main()&#123; int startx,starty; scanf(&quot;%d%d&quot;,&amp;m,&amp;n); for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=n;j+=)&#123; scanf(&quot;%d&quot;,&amp;a[i][j]); &#125; &#125; scanf(&quot;%d%d%d%d&quot;,&amp;startx,&amp;starty,&amp;p,&amp;q); v[startx][starty] = 1; dfs(startx,starty,0); printf(&quot;%d&quot;,min); return 0;&#125; 11.双指针&amp;&amp;滑动窗口​ 基本思想就是将串划分子段,如果出现重复，则滑动窗口，变更start的位置，统计新的子串的长度，同时不断更新结果值 class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int map[128] = &#123;0&#125;, len = 0, start = 0; //map统计字符在当前子串出现次数,字符的ascii码值小于128 for(int i = 0; i &lt; s.size(); ++i) &#123; ++map[s[i]]; while(map[s[i]] == 2) //出现重复 --map[s[start++]]; //不断滑动右移的同时恢复map中的状态，当map[s[i]]=1时，确定新的start len = max(len, i - start + 1); &#125; return len; &#125;&#125;; 12.Moore投票法摩尔投票法，解决的问题是如何在任意多的候选人中，选出票数超过一半的那个人。注意，是超出一半票数的那个人。 假设投票是这样的，[A, C, A, A, B]，ABC 是指三个候选人。 第一张票与第二张票进行对坑，如果票不同则互相抵消掉； 接着第三票与第四票进行对坑，如果票相同，则增加这个候选人的可抵消票数； 这个候选人拿着可抵消票数与第五张票对坑，如果票不同，则互相抵消掉，即候选人的可抵消票数 -1。 class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; int first_Candidate = 0; int second_Candidate = 0; int num1 = 0; int num2 = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] == first_Candidate) num1 ++; else if (nums[i] == second_Candidate) num2 ++; else if (num1 == 0) &#123; first_Candidate = nums[i]; num1 ++; &#125; else if (num2 == 0) &#123; second_Candidate = nums[i]; num2 ++; &#125; else &#123; num1 --; num2 --; &#125; &#125; num1 = 0; num2 = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] == first_Candidate) num1 ++; if (nums[i] == second_Candidate) num2 ++; &#125; vector&lt;int&gt; result; if (num1 &gt; nums.size() / 3) result.push_back(first_Candidate); if (num2 &gt; nums.size() / 3 &amp;&amp; first_Candidate != second_Candidate) result.push_back(second_Candidate); return result; &#125;&#125;; 13.BFS//迷宫问题#includebits/stdc++.husing namespace std;int a[100][100];//a【i】【j】=1表示是空地可以走，为0表示不是空地int v[100][100];//v【i】【j】=1表示已经被访问了，为0表示未被访问struct point&#123; int x; int y; int step;&#125;;queue&lt;point&gt; r;//request queueint dx[4]=&#123;0,1,0,-1&#125;; //left;down;right;upint dy[4]=&#123;1,0,-1,0&#125;;int main() &#123; //input int n,m,startx,starty,p,q; scanf(%d%d,&amp;n,&amp;m); for(int i=1;i=n;i++)&#123; for(int j=1;j=m;j++)&#123; scanf(%d,&amp;a[i][j]); &#125; &#125; scanf(%d%d%d%d,&amp;startx,&amp;starty,&amp;p,&amp;q); //BFS point start; //初始化开始 start.x = startx; start.y = starty; start.step = 0; //初始化结束 r.push(start);//将起点入队 v[startx][starty] = 1 ; int flag = 0; while(!r.empty())&#123; if(x==p &amp;&amp; y==q)&#123;// arrive destinationa flag = 1; coutr.front().step; break; &#125; int x = r.front().x; int y = r.front().y; for(int k = 0 ; k &lt; 3 ; k++)&#123; int tx,ty; tx = x + dx[k]; ty = y + dy[k]; if (a[tx][ty]==1 &amp;&amp; v[tx][ty]==0)&#123;//如果是空地 并且 未被访问过 //入队 point temp;//把拓展的点放到temp里 temp.x = tx; temp.y = ty; temp.step = r.front().step + 1 ; r.push(temp); v[tx][ty] = 1; //设置为已访问 &#125; &#125; r.pop();//拓展完了需要将队首元素出队 &#125; if(flag==0)//没找到 cout&lt;&lt;no answer&lt;&lt;endl; return 0;&#125; //马的遍历#include &lt;bits/stdc++.h&gt;using namespace std;struct point&#123; int x; int y; int step;&#125;;queue&lt;point&gt; r;int dx[8] = &#123;-1,-2,-2,-1,1,2,2,1&#125;;int dy[8] = &#123;-2,-1,1,2,2,1,-1,-2&#125;;int a[500][500];int check[500][500];//main programint main()&#123; int n,m; // width and length int fx,fy; int startx,starty; cin&gt;&gt;n&gt;&gt;m&gt;&gt;fx&gt;&gt;fy; startx = fx - 1,starty = fy - 1; int a[n][m]; memset(a,-1,sizeof(a)); memset(check,0,sizeof(check)); point start; start.x = startx, start.y = starty,start.step = 0; r.push(start); a[startx][starty] = 0; check[startx][starty] = 1; while(!r.empty())&#123; int next_x = r.front().x; int next_y = r.front().y; for(int k=0;k&lt;8;k++)&#123; int tx,ty; tx = next_x + dx[k]; ty = next_y + dy[k]; if (tx&lt;0||tx&gt;n-1||ty&lt;0||ty&gt;m-1) continue; else if (check[tx][ty] == 1) continue; else&#123; point temp; temp.x = tx; temp.y = ty; temp.step = r.front().step + 1; r.push(temp); a[tx][ty] = temp.step; check[tx][ty] = 1; &#125; &#125; r.pop(); &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; printf(&quot;%-5d&quot;,a[i][j]); &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 14.优先队列他和queue不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队 优先队列具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的 //升序队列priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//降序队列priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q; #include&lt;stdio.h&gt; #include&lt;functional&gt; #include&lt;queue&gt; #include&lt;vector&gt; using namespace std; //定义结构，使用运算符重载,自定义优先级1 struct cmp1&#123; bool operator ()(int &amp;a,int &amp;b)&#123; return a&gt;b;//最小值优先 &#125; &#125;; struct cmp2&#123; bool operator ()(int &amp;a,int &amp;b)&#123; return a&lt;b;//最大值优先 &#125; &#125;; //定义结构，使用运算符重载,自定义优先级2 struct number1&#123; int x; bool operator &lt; (const number1 &amp;a) const &#123; return x&gt;a.x;//最小值优先 &#125; &#125;; struct number2&#123; int x; bool operator &lt; (const number2 &amp;a) const &#123; return x&lt;a.x;//最大值优先 &#125; &#125;; int a[]=&#123;14,10,56,7,83,22,36,91,3,47,72,0&#125;; number1 num1[]=&#123;14,10,56,7,83,22,36,91,3,47,72,0&#125;; number2 num2[]=&#123;14,10,56,7,83,22,36,91,3,47,72,0&#125;; int main() &#123; priority_queue&lt;int&gt;que;//采用默认优先级构造队列 priority_queue&lt;int,vector&lt;int&gt;,cmp1&gt;que1;//最小值优先 priority_queue&lt;int,vector&lt;int&gt;,cmp2&gt;que2;//最大值优先 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;que3;//注意“&gt;&gt;”会被认为错误， //这是右移运算符，所以这里用空格号隔开 priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;que4;////最大值优先 priority_queue&lt;number1&gt;que5; priority_queue&lt;number2&gt;que6;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://47.118.73.148/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://47.118.73.148/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"MATLAB入门笔记","slug":"matlab入门笔记","date":"2021-06-07T17:45:12.000Z","updated":"2021-06-08T11:57:48.174Z","comments":true,"path":"2021/06/08/matlab入门笔记/","link":"","permalink":"http://47.118.73.148/2021/06/08/matlab%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1.简单函数：1.1 linspace 函数： 可以用于产生x1,x2之间的N点行线性的矢量，linspace(x1,x2,N) 调用方法：linspace(x1,x2,N) 功 能：用于产生x1，x2之间的N点行矢量，相邻数据跨度相同。其中x1、x2、N分别为起始值、终止值、元素个数。若缺省N，默认点数为100。 1.2 zeros函数 zeros(x,y) 生成一个x行y列的矩阵 1.3.ones函数 生成所有元素都为1的方阵 1.4.eye函数 生成单位向量 1.5.rand函数 Ran(x,y) 生成x到y的随机数 2.字符短语pi为派；i表示复数；inf为无穷大；NaN无意义(not a number); clc清屏; clear all 清除所有变量; close all 关闭所有窗口 3.基本运算符号：*为乘号 ；.*为点乘（对应位置相乘）./除号同理 ；加.后为对应位置计算^阶乘 4.取出矩阵中的值 &amp;&amp; 赋值：A = [1 2 3 ; 4 5 6 ; 7 8 9];x = A(1,3) % 取第一行第三列y = A(2,:) % 取第二行全部z = A(1:2, 1:3) %取第一到第二行的第一到第三列A(1,3) = 0 %给第一行第三列赋值A(2, : ) = [6 5 4] %给第二行赋值A(1:2, 1:2) = [-1 -2; -3 -4] %给第一到第二行的第一到第二列赋值 5.比较和逻辑运算eq = (x==y) %比较x与y矩阵各个位置大小并按位输出 0 1xy = (x&gt;5)&amp;(y&lt;7) %判断各个位置是否满足并输出 0 1 &amp;为“与”xoy = (x&gt;5)|(y&lt;7) %或x(x&lt;0) = 0 %把x中小于0的值赋值为0y(y(:,1)&lt;0,:) = 0 % 先判断该行第一列的值是否&lt;0，若是则将该行赋值为0 6.数组操作函数y = flipud(x) %翻转矩阵 第一行到最后一行 以此类推c = rot90(x) % 矩阵旋转90度 第一行到第一列sum(x) % 对x中各元素进行求和 若是多行矩阵，则对各列进行求和sum(x,2) % 对x中每一行各元素进行求和max(x) %求各元素最大值 若是多行矩阵，则求各列最大值max(x,2) %将矩阵中各元素与2进行比较并输出较大的值max(x,[],2) %求各行最大值 7.常用数学函数：y = abs(x) %对矩阵中各个元素求绝对值z = sqrt(y) %对矩阵中各元素开方%取整：y = ceil(x) %向上取整z = floor(x) %向上取整a = fix(x) %取整数部分b = round(x) % 四舍五入 8.基本语句：for .. endif .. else .. endwhile .. endswitch .. case .. end%sum of the odd number between 1 and 10x = 0;for i = 1:10 if mod(i,2) x = x + i; endend 9.二维曲线：sin &amp; cosplot %描点画图x = -2*pi:0.1:2*pi; % -2pi到2pi 步长为0.1y1 = sin(x);y2 = cos(x);plot(x,y1,&#x27;-b&#x27;); %-表示实线 b表示颜色hold on %保持现在的图窗 下一个图形也会画在该图上plot(x, y2,&#x27;-r&#x27;);xlabel(&#x27;x&#x27;); %定义坐标名为xylabel(&#x27;y&#x27;); %定义坐标名为ytext(0,0, &#x27;(0,0)&#x27;) %在坐标(0,0)处显示‘(0,0)’字符legend(&#x27;sin x&#x27;,&#x27;cos x&#x27;) %图例函数 title(&#x27;sin x and cos x&#x27;) %标题axis([-20,20,-20,15]); %坐标轴限制 分别为x最小值 x最大值 y最小值 y最大值 %plot用法总结：color: b-blue g-green r-red c-cyan m-megenta y-yellow k-black w-whitegrid on %加网格线 grid minor %网格线变得更密xlim([xmin,xmax]) or ylim([ymin,ymax]); %单独限制x or y坐标范围 10.二维曲线：对数和极坐标系loglog(x,y,&#x27;-r&#x27;) %x和y轴都为对数坐标semilogx(x,y,&#x27;-r&#x27;) %x轴是对数坐标系 semilogy同理y = exp(x) %对数函数 值为e^x%极坐标系theta = 0:pi/180:4*pi %定角度r = 1-sin(theta);polar(theta,r,&#x27;-r&#x27;); %绘制极坐标系图 11.二维填充：x = [-1,-1,1,1];y = [-1,1,1,-1];h = fill(x,y,&#x27;-r&#x27;); %利用fill函数进行填充xc = [-2 2]; yc = [-2 2];x = [xc-1; xc-1; xc+1; xc+1]y = [yc-1; yc+1; yc+1; yc-1]h = fill(x, y, &#x27;b&#x27;); %按列的顺序绘制多个图形set(h(1),&#x27;FaceColor&#x27;, &#x27;r&#x27;) %指定单个图形的颜色 1为第一个出现的图形set(h(2),&#x27;xdata&#x27;,x(:,2)-2) %需改单个图形的值 此处为修改第二个图形的x坐标 12.数组显示：x = [1 2 3; 4 5 6;7 8 9];imagesc(x); %将数组用图形画出来 13.三维曲线：t = 0:pi/50:10*pi;x = sin(t);y = cos(t);z = t;plot3(x,y,z)title(&#x27;Helix&#x27;)xlabel(&#x27;sin t&#x27;)ylabel(&#x27;cos t&#x27;)zlabel(&#x27;t&#x27;)grid on 14.三维曲面：meshgrid() %生成网格矩阵[x , y] = meshgrid(1:3, 1:3) %生成sinxcosy[x,y] = meshgrid(-pi:0.1:pi);z = sin(x).*cos(y);mesh(x,y,z) %meshc()可投影到底面surf(x,y,z) %surfc()可投影到底面xlabel(&#x27;x&#x27;)ylabel(&#x27;y&#x27;)zlabel(&#x27;z&#x27;)title(&#x27;sin x sin y&#x27;) 15.函数：function[output1, ..] = functionname(input1, ..)% comment of this functionMatlab command 1;Matlab command 2;%examplefunction [s] = areamath(w,l)s = w.*l;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://47.118.73.148/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MATLAB","slug":"matlab","permalink":"http://47.118.73.148/tags/matlab/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"http://47.118.73.148/categories/%E7%AC%94%E8%AE%B0/"},{"name":"教程","slug":"教程","permalink":"http://47.118.73.148/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://47.118.73.148/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Git","slug":"git","permalink":"http://47.118.73.148/tags/git/"},{"name":"JAVA","slug":"java","permalink":"http://47.118.73.148/tags/java/"},{"name":"代跑","slug":"代跑","permalink":"http://47.118.73.148/tags/%E4%BB%A3%E8%B7%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://47.118.73.148/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"MATLAB","slug":"matlab","permalink":"http://47.118.73.148/tags/matlab/"}]}